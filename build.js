#!/usr/bin/env node

/**
 * Build script for TimeFlow Card - Modular Architecture
 * Bundles all modules into a single file for distribution
 */

const fs = require('fs');
const path = require('path');

const srcDir = path.join(__dirname, 'src');
const distFile = path.join(__dirname, 'timeflow-card-modular.js');

/**
 * Transpile decorators to static properties for Lit components
 * @param {string} content - File content with decorators
 * @returns {string} - Content with transpiled decorators
 */
function transpileDecorators(content) {
  let result = content;
  
  // Handle @property decorators - extract configurations for static properties
  const propertyMatches = [...content.matchAll(/@property\(\s*\{([^}]+)\}\s*\)\s+(\w+)\s*=\s*([^;]+);?/g)];
  
  // Handle @state decorators
  result = result.replace(
    /@state\(\)\s+(\w+)\s*=\s*([^;]+);?/g,
    '$1 = $2;'
  );
  
  // Handle @property decorators - remove decorator and keep property
  result = result.replace(
    /@property\(\s*\{([^}]+)\}\s*\)\s+(\w+)\s*=\s*([^;]+);?/g,
    '$2 = $3;'
  );
  
  // Add static properties definition for classes that had @property decorators
  if (propertyMatches.length > 0) {
    result = result.replace(
      /class\s+(\w+)\s+extends\s+LitElement\s*\{/,
      (match, className) => {
        let staticProperties = '  static properties = {\n';
        
        propertyMatches.forEach(([, config, name]) => {
          staticProperties += `    ${name}: { ${config} },\n`;
        });
        
        staticProperties += '  };\n\n';
        
        return `${match}\n${staticProperties}`;
      }
    );
  }
  
  return result;
}

/**
 * Resolves ES6 imports and bundles files
 */
function bundleFiles() {
  const processedFiles = new Set();
  
  function processFile(filePath) {
    if (processedFiles.has(filePath)) {
      return '';
    }
    
    processedFiles.add(filePath);
    
    if (!fs.existsSync(filePath)) {
      console.warn(`Warning: File not found: ${filePath}`);
      return '';
    }
    
    let content = fs.readFileSync(filePath, 'utf8');
    
    // Transpile decorators first
    content = transpileDecorators(content);
    
    // Extract and process imports
    const importRegex = /import\s+\{([^}]+)\}\s+from\s+['"]([^'"]+)['"];?\s*/g;
    let match;
    
    while ((match = importRegex.exec(content)) !== null) {
      const importPath = match[2];
      let resolvedPath;
      
      if (importPath.startsWith('./') || importPath.startsWith('../')) {
        // Relative import
        resolvedPath = path.resolve(path.dirname(filePath), importPath);
        if (!resolvedPath.endsWith('.js')) {
          resolvedPath += '.js';
        }
      } else {
        // Absolute import from src
        resolvedPath = path.join(srcDir, importPath);
        if (!resolvedPath.endsWith('.js')) {
          resolvedPath += '.js';
        }
      }
      
      // Process the imported file recursively
      const importedContent = processFile(resolvedPath);
      
      // Remove the import statement
      content = content.replace(match[0], '');
      
      // Add the imported content at the beginning
      content = importedContent + '\n' + content;
    }
    
    // Remove export statements and convert to regular declarations
    content = content.replace(/export\s+class\s+/g, 'class ');
    content = content.replace(/export\s+\{[^}]+\};\s*$/gm, '');
    content = content.replace(/export\s+default\s+/g, '');
    
    return content;
  }
  
  // Start with the entry point
  const entryPoint = path.join(srcDir, 'index.js');
  let bundledContent = processFile(entryPoint);
  
  // Add header comment
  const header = `/**
 * TimeFlow Card - Modular Architecture Bundle
 * Generated on ${new Date().toISOString()}
 * 
 * This file is automatically generated from the modular source files.
 * For development, see the individual files in the src/ directory.
 */

`;
  
  bundledContent = header + bundledContent;
  
  // Write the bundled file
  fs.writeFileSync(distFile, bundledContent, 'utf8');
  
  console.log(`‚úÖ Bundle created: ${distFile}`);
  console.log(`üì¶ Size: ${(fs.statSync(distFile).size / 1024).toFixed(2)} KB`);
  console.log(`üîß Processed ${processedFiles.size} files`);
}

/**
 * Watches for changes during development
 */
function watchFiles() {
  console.log('üëÄ Watching for changes...');
  
  function watchDirectory(dir) {
    fs.readdirSync(dir).forEach(file => {
      const filePath = path.join(dir, file);
      const stat = fs.statSync(filePath);
      
      if (stat.isDirectory()) {
        watchDirectory(filePath);
      } else if (file.endsWith('.js')) {
        fs.watchFile(filePath, () => {
          console.log(`üìù Changed: ${filePath}`);
          bundleFiles();
        });
      }
    });
  }
  
  watchDirectory(srcDir);
}

// Main execution
if (require.main === module) {
  const args = process.argv.slice(2);
  
  if (args.includes('--watch') || args.includes('-w')) {
    bundleFiles();
    watchFiles();
  } else {
    bundleFiles();
  }
}

module.exports = { bundleFiles };
