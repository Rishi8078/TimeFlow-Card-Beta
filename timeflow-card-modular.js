/**
 * TimeFlow Card - Modular Architecture Bundle
 * Generated on 2025-07-23T21:32:38.640Z
 * 
 * This file is automatically generated from the modular source files.
 * For development, see the individual files in the src/ directory.
 */


/**
 * ProgressCircle - Modular progress circle component with accessibility
 * Provides visual progress indication with keyboard navigation support
 */
class ProgressCircle extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this._progress = 0;
    this._color = '#4CAF50';
    this._size = 100;
    this._strokeWidth = 15;
    this._lastAnnouncedProgress = -1;
    this._accessibilityManager = null;
  }

  static get observedAttributes() {
    return ['progress', 'color', 'size', 'stroke-width'];
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue !== newValue) {
      switch (name) {
        case 'progress':
          this._progress = Math.max(0, Math.min(100, parseFloat(newValue) || 0));
          break;
        case 'color':
          this._color = newValue || '#4CAF50';
          break;
        case 'size':
          this._size = parseInt(newValue) || 100;
          break;
        case 'stroke-width':
          this._strokeWidth = parseInt(newValue) || 15;
          break;
      }
      this.render();
    }
  }

  /**
   * Sets up accessibility features
   */
  setupAccessibility() {
    const circle = this.shadowRoot.querySelector('.progress-circle');
    if (circle) {
      circle.setAttribute('tabindex', '0');
      circle.setAttribute('role', 'progressbar');
      circle.setAttribute('aria-valuenow', Math.round(this._progress));
      circle.setAttribute('aria-valuemin', '0');
      circle.setAttribute('aria-valuemax', '100');
      circle.setAttribute('aria-label', `Progress: ${Math.round(this._progress)}%`);
      
      // Add keyboard event listeners
      circle.addEventListener('keydown', this._handleKeydown.bind(this));
      circle.addEventListener('focus', this._handleFocus.bind(this));
      circle.addEventListener('blur', this._handleBlur.bind(this));
    }
  }

  /**
   * Handles keyboard navigation
   * @param {KeyboardEvent} event - Keyboard event
   */
  _handleKeydown(event) {
    switch (event.key) {
      case 'Enter':
      case ' ':
        event.preventDefault();
        this._announceProgress();
        break;
      case 'ArrowUp':
      case 'ArrowRight':
        event.preventDefault();
        this._simulateProgressChange(5);
        break;
      case 'ArrowDown':
      case 'ArrowLeft':
        event.preventDefault();
        this._simulateProgressChange(-5);
        break;
    }
  }

  /**
   * Handles focus events
   * @param {FocusEvent} event - Focus event
   */
  _handleFocus(event) {
    const circle = this.shadowRoot.querySelector('.progress-circle');
    if (circle) {
      circle.style.outline = '2px solid var(--primary-color, #03A9F4)';
      circle.style.outlineOffset = '2px';
    }
    
    // Announce progress when focused
    setTimeout(() => this._announceProgress(), 100);
  }

  /**
   * Handles blur events
   * @param {FocusEvent} event - Blur event
   */
  _handleBlur(event) {
    const circle = this.shadowRoot.querySelector('.progress-circle');
    if (circle) {
      circle.style.outline = 'none';
    }
  }

  /**
   * Announces current progress
   */
  _announceProgress() {
    const progress = Math.round(this._progress);
    if (progress !== this._lastAnnouncedProgress) {
      this._createLiveRegionAnnouncement(`Progress: ${progress}%`);
      this._lastAnnouncedProgress = progress;
    }
  }

  /**
   * Simulates progress change for demonstration (read-only in practice)
   * @param {number} delta - Change in progress
   */
  _simulateProgressChange(delta) {
    // In practice, this would be read-only, but for accessibility demo
    const newProgress = Math.max(0, Math.min(100, this._progress + delta));
    this.setAttribute('progress', newProgress);
    this._announceProgress();
  }

  /**
   * Creates live region announcement
   * @param {string} message - Message to announce
   */
  _createLiveRegionAnnouncement(message) {
    // Remove any existing announcements
    const existingAnnouncement = this.shadowRoot.querySelector('.live-announcement');
    if (existingAnnouncement) {
      existingAnnouncement.remove();
    }

    // Create new announcement
    const announcement = document.createElement('div');
    announcement.className = 'live-announcement';
    announcement.setAttribute('aria-live', 'assertive');
    announcement.style.position = 'absolute';
    announcement.style.left = '-10000px';
    announcement.style.width = '1px';
    announcement.style.height = '1px';
    announcement.style.overflow = 'hidden';
    announcement.textContent = message;

    this.shadowRoot.appendChild(announcement);

    // Remove announcement after it's been read
    setTimeout(() => {
      if (announcement.parentNode) {
        announcement.remove();
      }
    }, 1000);
  }

  connectedCallback() {
    this.render();
    setTimeout(() => this.setupAccessibility(), 0);
  }

  render() {
    const radius = (this._size - this._strokeWidth) / 2;
    const circumference = 2 * Math.PI * radius;
    const strokeDashoffset = circumference - (this._progress / 100) * circumference;

    this.shadowRoot.innerHTML = `
      <style>
        :host {
          display: inline-block;
          --progress-color: ${this._color};
        }
        
        .progress-circle {
          transform: rotate(-90deg);
          border-radius: 50%;
          cursor: pointer;
          transition: all 0.3s ease;
        }
        
        .progress-circle:focus {
          outline: 2px solid var(--primary-color, #03A9F4);
          outline-offset: 2px;
        }
        
        .progress-background {
          fill: none;
          stroke: rgba(255, 255, 255, 0.1);
          stroke-width: ${this._strokeWidth};
        }
        
        .progress-bar {
          fill: none;
          stroke: var(--progress-color);
          stroke-width: ${this._strokeWidth};
          stroke-linecap: round;
          stroke-dasharray: ${circumference};
          stroke-dashoffset: ${strokeDashoffset};
          transition: stroke-dashoffset 0.3s ease, stroke 0.3s ease;
        }
        
        .progress-text {
          fill: currentColor;
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
          font-size: ${Math.max(12, this._size * 0.15)}px;
          font-weight: 600;
          text-anchor: middle;
          dominant-baseline: middle;
          transform: rotate(90deg);
          opacity: 0.8;
        }
        
        /* Hover effects */
        .progress-circle:hover .progress-bar {
          stroke-width: ${this._strokeWidth + 2};
        }
        
        /* Animation for progress changes */
        @keyframes progress-pulse {
          0% { opacity: 0.8; }
          50% { opacity: 1; }
          100% { opacity: 0.8; }
        }
        
        .progress-circle.updating .progress-bar {
          animation: progress-pulse 0.5s ease-in-out;
        }
      </style>
      
      <svg 
        class="progress-circle" 
        width="${this._size}" 
        height="${this._size}"
        tabindex="0"
        role="progressbar"
        aria-valuenow="${Math.round(this._progress)}"
        aria-valuemin="0"
        aria-valuemax="100"
        aria-label="Timer progress: ${Math.round(this._progress)}% complete"
      >
        <circle
          class="progress-background"
          cx="${this._size / 2}"
          cy="${this._size / 2}"
          r="${radius}"
        />
        <circle
          class="progress-bar"
          cx="${this._size / 2}"
          cy="${this._size / 2}"
          r="${radius}"
        />
        <text
          class="progress-text"
          x="${this._size / 2}"
          y="${this._size / 2}"
        >
          ${Math.round(this._progress)}%
        </text>
      </svg>
    `;
  }

  /**
   * Updates progress with optional animation
   * @param {number} progress - New progress value
   * @param {boolean} animate - Whether to animate the change
   */
  updateProgress(progress, animate = true) {
    const circle = this.shadowRoot.querySelector('.progress-circle');
    
    if (animate && circle) {
      circle.classList.add('updating');
      setTimeout(() => {
        circle.classList.remove('updating');
      }, 500);
    }
    
    this.setAttribute('progress', progress);
  }

  /**
   * Gets current progress value
   * @returns {number} - Current progress
   */
  getProgress() {
    return this._progress;
  }
}

/**
 * AccessibilityManager - Handles all accessibility features and interactions
 * Provides WCAG 2.1 AA compliant accessibility support
 */
class AccessibilityManager {
  constructor() {
    this.accessibilityIds = {};
    this.domElements = {};
    this.boundHandlers = {};
  }

  /**
   * Generates unique IDs for accessibility
   * @returns {Object} - Object with accessibility IDs
   */
  generateAccessibilityIds() {
    this.accessibilityIds = {
      cardId: `timeflow-card-${Math.random().toString(36).substr(2, 9)}`,
      titleId: `title-${Math.random().toString(36).substr(2, 9)}`,
      subtitleId: `subtitle-${Math.random().toString(36).substr(2, 9)}`,
      progressId: `progress-${Math.random().toString(36).substr(2, 9)}`,
      liveRegionId: `live-region-${Math.random().toString(36).substr(2, 9)}`
    };
    return this.accessibilityIds;
  }

  /**
   * Sets up keyboard navigation for the card
   * @param {HTMLElement} shadowRoot - Shadow root element
   * @param {Object} domElements - DOM element references
   */
  setupCardKeyboardNavigation(shadowRoot, domElements) {
    this.domElements = domElements;
    
    if (shadowRoot && domElements.haCard) {
      // Bind methods to preserve context
      this.boundHandlers.keydown = this.handleCardKeydown.bind(this);
      this.boundHandlers.focus = this.handleCardFocus.bind(this);
      this.boundHandlers.blur = this.handleCardBlur.bind(this);
      
      domElements.haCard.addEventListener('keydown', this.boundHandlers.keydown);
      domElements.haCard.addEventListener('focus', this.boundHandlers.focus);
      domElements.haCard.addEventListener('blur', this.boundHandlers.blur);
    }
  }
  
  /**
   * Removes keyboard navigation listeners
   */
  removeCardKeyboardNavigation() {
    if (this.domElements.haCard && this.boundHandlers.keydown) {
      this.domElements.haCard.removeEventListener('keydown', this.boundHandlers.keydown);
      this.domElements.haCard.removeEventListener('focus', this.boundHandlers.focus);
      this.domElements.haCard.removeEventListener('blur', this.boundHandlers.blur);
    }
  }
  
  /**
   * Handles keyboard events for the card
   * @param {KeyboardEvent} event - Keyboard event
   */
  handleCardKeydown(event) {
    switch (event.key) {
      case 'Enter':
      case ' ':
        event.preventDefault();
        this.announceCardStatus();
        break;
      case 'Tab':
        // Allow natural tab navigation
        break;
      case 'r':
      case 'R':
        if (event.ctrlKey || event.metaKey) {
          event.preventDefault();
          this.refreshCard();
        }
        break;
      case 'i':
      case 'I':
        event.preventDefault();
        this.announceCardInfo();
        break;
    }
  }
  
  /**
   * Handles focus events for the card
   * @param {FocusEvent} event - Focus event
   */
  handleCardFocus(event) {
    // Announce card when focused
    setTimeout(() => {
      this.announceCardStatus();
    }, 100);
  }
  
  /**
   * Handles blur events for the card
   * @param {FocusEvent} event - Blur event
   */
  handleCardBlur(event) {
    // Could implement any cleanup when focus leaves the card
  }

  /**
   * Announces the current card status
   */
  announceCardStatus() {
    if (!this.config || !this.countdownService) return;
    
    const title = this.config.title || 'Countdown Timer';
    const subtitle = this.countdownService.getSubtitle(this.config);
    const progress = Math.round(this.currentProgress || 0);
    const status = this.countdownService.isExpired() ? 'expired' : 'active';
    
    const announcement = `${title}. ${status} timer. ${subtitle}. Progress: ${progress}% complete.`;
    this.updateLiveRegion(announcement);
  }
  
  /**
   * Announces card information
   */
  announceCardInfo() {
    if (!this.config) return;
    
    const { target_date, creation_date } = this.config;
    const targetInfo = typeof target_date === 'string' ? 
      `Target date: ${new Date(target_date).toLocaleDateString()}` : 
      `Target entity: ${target_date}`;
    
    const creationInfo = creation_date ? 
      `Started: ${new Date(creation_date).toLocaleDateString()}` : 
      'No start date set';
    
    const announcement = `Timer information. ${targetInfo}. ${creationInfo}.`;
    this.updateLiveRegion(announcement);
  }
  
  /**
   * Refreshes the card (to be implemented by parent)
   */
  refreshCard() {
    if (this.onRefresh) {
      this.onRefresh();
    }
    this.updateLiveRegion('Card refreshed');
  }
  
  /**
   * Updates the live region with a message
   * @param {string} message - Message to announce
   */
  updateLiveRegion(message) {
    if (this.domElements && this.domElements.liveRegion) {
      // Clear and update live region
      this.domElements.liveRegion.textContent = '';
      setTimeout(() => {
        this.domElements.liveRegion.textContent = message;
      }, 10);
      
      // Clear after announcement
      setTimeout(() => {
        if (this.domElements && this.domElements.liveRegion) {
          this.domElements.liveRegion.textContent = '';
        }
      }, 3000);
    }
  }

  /**
   * Updates accessibility attributes based on current state
   * @param {number} progress - Current progress percentage
   * @param {string} subtitle - Current subtitle text
   */
  updateAccessibilityAttributes(progress, subtitle) {
    this.currentProgress = progress;
    
    if (this.domElements) {
      // Update progress description
      if (this.domElements.progressDescription) {
        this.domElements.progressDescription.textContent = `Progress: ${Math.round(progress)}% complete`;
      }
      
      // Update progress circle attributes
      if (this.domElements.progressCircle) {
        this.domElements.progressCircle.setAttribute('aria-label', `Timer progress: ${Math.round(progress)}% complete`);
      }
      
      // Update subtitle aria-live region
      if (this.domElements.subtitle) {
        this.domElements.subtitle.textContent = subtitle || '0s';
      }
    }
  }

  /**
   * Generates accessibility-focused HTML structures
   * @param {Object} ids - Accessibility IDs
   * @param {boolean} expired - Whether timer is expired
   * @param {string} subtitleText - Current subtitle text
   * @param {number} progress - Current progress percentage
   * @returns {string} - HTML string with accessibility features
   */
  generateAccessibilityHTML(ids, expired, subtitleText, progress) {
    return `
      <!-- Screen reader only context -->
      <div class="sr-only">
        Timer card showing ${expired ? 'expired countdown' : 'active countdown'}.
        ${expired ? 'Timer has finished.' : `Time remaining: ${subtitleText}`}
      </div>
      
      <!-- Live region for dynamic updates -->
      <div 
        id="${ids.liveRegionId}"
        class="live-region"
        aria-live="polite"
        aria-atomic="true"
      ></div>
      
      <!-- Progress description for screen readers -->
      <span id="${ids.progressId}" class="sr-only">
        Progress: ${Math.round(progress)}% complete
      </span>
    `;
  }

  /**
   * Sets configuration and services for announcements
   * @param {Object} config - Card configuration
   * @param {Object} countdownService - Countdown service instance
   * @param {Function} onRefresh - Refresh callback
   */
  setContext(config, countdownService, onRefresh) {
    this.config = config;
    this.countdownService = countdownService;
    this.onRefresh = onRefresh;
  }

  /**
   * Gets accessibility IDs
   * @returns {Object} - Accessibility IDs object
   */
  getAccessibilityIds() {
    return this.accessibilityIds;
  }

  /**
   * Cleans up accessibility manager
   */
  cleanup() {
    this.removeCardKeyboardNavigation();
    this.domElements = {};
    this.boundHandlers = {};
    this.accessibilityIds = {};
  }
}

/**
 * StyleManager - Handles styling calculations and CSS processing
 * Provides dynamic sizing, proportional scaling, and style management
 */
class StyleManager {
  constructor() {
    this.cache = {
      dynamicIconSize: null,
      dynamicStrokeWidth: null,
      customStyles: null,
      lastConfigHash: null
    };
  }

  /**
   * Processes styles array into CSS string
   * @param {Array} styles - Array of style objects or strings
   * @returns {string} - CSS string
   */
  processStyles(styles) {
    if (!styles || !Array.isArray(styles)) return '';
    
    return styles.map(style => {
      try {
        if (typeof style === 'string') {
          return style;
        } else if (typeof style === 'object' && style !== null) {
          return Object.entries(style)
            .map(([prop, value]) => `${prop}: ${value}`)
            .join('; ');
        }
        return '';
      } catch (e) {
        console.warn('TimeFlow Card: Error processing style:', style, e);
        return '';
      }
    }).join('; ');
  }

  /**
   * Builds styles object from configuration
   * @param {Object} config - Card configuration
   * @returns {Object} - Processed styles object
   */
  buildStylesObject(config) {
    // Use cached value if available and config hasn't changed
    const configHash = JSON.stringify(config.styles || {});
    if (this.cache.customStyles !== null && this.cache.lastConfigHash === configHash) {
      return this.cache.customStyles;
    }

    const { styles = {} } = config;
    
    try {
      const processedStyles = {
        card: this.processStyles(styles.card),
        title: this.processStyles(styles.title),
        subtitle: this.processStyles(styles.subtitle),
        progress_circle: this.processStyles(styles.progress_circle)
      };

      this.cache.customStyles = processedStyles;
      this.cache.lastConfigHash = configHash;
      return processedStyles;
    } catch (e) {
      console.warn('TimeFlow Card: Error building styles object:', e);
      this.cache.customStyles = {
        card: '',
        title: '',
        subtitle: '',
        progress_circle: ''
      };
      return this.cache.customStyles;
    }
  }

  /**
   * Calculate dynamic icon size based on card dimensions - now truly proportional
   * @param {*} width - Card width
   * @param {*} height - Card height
   * @param {string} aspect_ratio - Aspect ratio string
   * @param {*} icon_size - Explicit icon size
   * @returns {number} - Calculated icon size in pixels
   */
  calculateDynamicIconSize(width, height, aspect_ratio, icon_size) {
    // Use cached value if available and config hasn't changed
    const configKey = JSON.stringify({ width, height, aspect_ratio, icon_size });
    if (this.cache.dynamicIconSize !== null && this.cache.lastIconConfigHash === configKey) {
      return this.cache.dynamicIconSize;
    }

    try {
      // Default card dimensions if not specified
      const defaultWidth = 300;
      const defaultHeight = 150;

      let cardWidth = defaultWidth;
      let cardHeight = defaultHeight;

      // Calculate actual card dimensions
      if (width && height) {
        cardWidth = this.parseDimension(width) || defaultWidth;
        cardHeight = this.parseDimension(height) || defaultHeight;
      } else if (width && aspect_ratio) {
        cardWidth = this.parseDimension(width) || defaultWidth;
        const [ratioW, ratioH] = aspect_ratio.split('/').map(parseFloat);
        cardHeight = cardWidth * (ratioH / ratioW);
      } else if (height && aspect_ratio) {
        cardHeight = this.parseDimension(height) || defaultHeight;
        const [ratioW, ratioH] = aspect_ratio.split('/').map(parseFloat);
        cardWidth = cardHeight * (ratioW / ratioH);
      } else if (aspect_ratio) {
        const [ratioW, ratioH] = aspect_ratio.split('/').map(parseFloat);
        cardHeight = defaultWidth * (ratioH / ratioW);
        cardWidth = defaultWidth;
      }

      // Icon should be 35-45% of the smaller dimension for optimal proportion
      const minDimension = Math.min(cardWidth, cardHeight);
      const proportionalSize = minDimension * 0.4;

      // Respect explicit icon_size if provided, otherwise use proportional
      if (icon_size && icon_size !== '100px') {
        const baseIconSize = typeof icon_size === 'string' ? 
          parseInt(icon_size.replace('px', '')) : 
          (typeof icon_size === 'number' ? icon_size : proportionalSize);
        this.cache.dynamicIconSize = Math.max(40, Math.min(baseIconSize, minDimension * 0.6));
      } else {
        this.cache.dynamicIconSize = Math.max(40, Math.min(proportionalSize, 120));
      }

      this.cache.lastIconConfigHash = configKey;
      return this.cache.dynamicIconSize;
    } catch (error) {
      console.warn('TimeFlow Card: Error calculating dynamic icon size:', error);
      this.cache.dynamicIconSize = 80; // Safe fallback
      return this.cache.dynamicIconSize;
    }
  }

  /**
   * Calculate dynamic stroke width based on icon size
   * @param {number} iconSize - Icon size in pixels
   * @param {*} stroke_width - Explicit stroke width
   * @returns {number} - Calculated stroke width
   */
  calculateDynamicStrokeWidth(iconSize, stroke_width) {
    // Use cached value if available and config hasn't changed
    const configKey = JSON.stringify({ iconSize, stroke_width });
    if (this.cache.dynamicStrokeWidth !== null && this.cache.lastStrokeConfigHash === configKey) {
      return this.cache.dynamicStrokeWidth;
    }

    try {
      const baseStrokeWidth = typeof stroke_width === 'number' ? stroke_width : 15;
      
      // Scale stroke width proportionally to icon size
      // Base ratio: 15px stroke for 100px icon = 0.15
      const ratio = 0.15;
      const calculatedStroke = Math.round(iconSize * ratio);
      
      // Keep stroke width within reasonable bounds (4-20px)
      this.cache.dynamicStrokeWidth = Math.max(4, Math.min(calculatedStroke, 20));
      this.cache.lastStrokeConfigHash = configKey;
      return this.cache.dynamicStrokeWidth;
    } catch (error) {
      console.warn('TimeFlow Card: Error calculating dynamic stroke width:', error);
      this.cache.dynamicStrokeWidth = 12; // Safe fallback
      return this.cache.dynamicStrokeWidth;
    }
  }

  /**
   * Calculate proportional font sizes based on card dimensions
   * @param {*} width - Card width
   * @param {*} height - Card height
   * @param {string} aspect_ratio - Aspect ratio string
   * @returns {Object} - Object with font sizes and dimensions
   */
  calculateProportionalSizes(width, height, aspect_ratio) {
    try {
      // Default card dimensions if not specified
      const defaultWidth = 300;
      const defaultHeight = 150;

      let cardWidth = defaultWidth;
      let cardHeight = defaultHeight;

      // Calculate actual card dimensions (same logic as icon size)
      if (width && height) {
        cardWidth = this.parseDimension(width) || defaultWidth;
        cardHeight = this.parseDimension(height) || defaultHeight;
      } else if (width && aspect_ratio) {
        cardWidth = this.parseDimension(width) || defaultWidth;
        const [ratioW, ratioH] = aspect_ratio.split('/').map(parseFloat);
        cardHeight = cardWidth * (ratioH / ratioW);
      } else if (height && aspect_ratio) {
        cardHeight = this.parseDimension(height) || defaultHeight;
        const [ratioW, ratioH] = aspect_ratio.split('/').map(parseFloat);
        cardWidth = cardHeight * (ratioW / ratioH);
      } else if (aspect_ratio) {
        const [ratioW, ratioH] = aspect_ratio.split('/').map(parseFloat);
        cardHeight = defaultWidth * (ratioH / ratioW);
        cardWidth = defaultWidth;
      }

      // Calculate proportional font sizes based on card area
      const cardArea = cardWidth * cardHeight;
      const scaleFactor = Math.sqrt(cardArea / (defaultWidth * defaultHeight));

      return {
        titleSize: Math.max(1.2, Math.min(2.2, 1.6 * scaleFactor)),
        subtitleSize: Math.max(0.9, Math.min(1.4, 1.1 * scaleFactor)),
        cardWidth,
        cardHeight
      };
    } catch (error) {
      console.warn('TimeFlow Card: Error calculating proportional sizes:', error);
      return { titleSize: 1.6, subtitleSize: 1.1, cardWidth: 300, cardHeight: 150 };
    }
  }

  /**
   * Helper to parse dimension strings (e.g., "200px", "100%") to numbers
   * @param {*} dimension - Dimension value to parse
   * @returns {number|null} - Parsed dimension in pixels
   */
  parseDimension(dimension) {
    try {
      if (typeof dimension === 'number') return dimension;
      if (typeof dimension !== 'string') return null;
      
      // Handle percentage values - assume 300px base for calculations
      if (dimension.includes('%')) {
        const percent = parseFloat(dimension.replace('%', ''));
        return isNaN(percent) ? null : (percent / 100) * 300; // 300px as base
      }
      
      // Handle pixel values
      if (dimension.includes('px')) {
        const pixels = parseFloat(dimension.replace('px', ''));
        return isNaN(pixels) ? null : pixels;
      }
      
      // Try to parse as number
      const parsed = parseFloat(dimension);
      return isNaN(parsed) ? null : parsed;
    } catch (error) {
      console.warn('TimeFlow Card: Error parsing dimension:', dimension, error);
      return null;
    }
  }

  /**
   * Generates card dimensions CSS based on configuration
   * @param {*} width - Card width
   * @param {*} height - Card height
   * @param {string} aspect_ratio - Aspect ratio string
   * @returns {Array} - Array of CSS style strings
   */
  generateCardDimensionStyles(width, height, aspect_ratio) {
    const cardStyles = [];
    
    // Apply width if specified
    if (width) {
      cardStyles.push(`width: ${width}`);
    }
    
    // Apply height if specified
    if (height) {
      cardStyles.push(`height: ${height}`);
    } else if (aspect_ratio) {
      // Use aspect-ratio if height not specified
      cardStyles.push(`aspect-ratio: ${aspect_ratio}`);
    } else {
      // Fallback minimum height
      cardStyles.push('min-height: 120px');
    }

    return cardStyles;
  }

  /**
   * Clears style cache
   */
  clearCache() {
    this.cache = {
      dynamicIconSize: null,
      dynamicStrokeWidth: null,
      customStyles: null,
      lastConfigHash: null
    };
  }
}

/**
 * CountdownService - Handles countdown calculations and time unit management
 * Provides clean separation of countdown logic from presentation
 */
class CountdownService {
  constructor(templateService, dateParser) {
    this.templateService = templateService;
    this.dateParser = dateParser;
    this.timeRemaining = { months: 0, days: 0, hours: 0, minutes: 0, seconds: 0, total: 0 };
    this.expired = false;
  }

  /**
   * Updates the countdown based on current configuration
   * @param {Object} config - Card configuration
   * @param {Object} hass - Home Assistant object
   * @returns {Promise<Object>} - Time remaining object
   */
  async updateCountdown(config, hass) {
    try {
      if (!config.target_date) return this.timeRemaining;
      
      const now = new Date().getTime();
      const targetDateValue = await this.templateService.resolveValue(config.target_date, hass);
      
      if (!targetDateValue) {
        console.warn('TimeFlow Card: Target date could not be resolved. Check your entity or date format.');
        return this.timeRemaining;
      }
      
      // Use the helper method for consistent date parsing
      const targetDate = this.dateParser.parseISODate(targetDateValue);
      
      if (isNaN(targetDate)) {
        console.warn('TimeFlow Card: Invalid target date format:', targetDateValue);
        return this.timeRemaining;
      }
      
      const difference = targetDate - now;

      if (difference > 0) {
        // Calculate time units based on what's enabled - cascade disabled units into enabled ones
        const { show_months, show_days, show_hours, show_minutes, show_seconds } = config;
        
        let totalMilliseconds = difference;
        let months = 0, days = 0, hours = 0, minutes = 0, seconds = 0;
        
        // Find the largest enabled unit and calculate everything from there
        if (show_months) {
          months = Math.floor(totalMilliseconds / (1000 * 60 * 60 * 24 * 30.44)); // Average month length
          totalMilliseconds %= (1000 * 60 * 60 * 24 * 30.44);
        }
        
        if (show_days) {
          days = Math.floor(totalMilliseconds / (1000 * 60 * 60 * 24));
          totalMilliseconds %= (1000 * 60 * 60 * 24);
        } else if (show_months && !show_days) {
          // If days are disabled but months are enabled, add days to months
          const extraDays = Math.floor(totalMilliseconds / (1000 * 60 * 60 * 24));
          months += Math.floor(extraDays / 30.44);
          totalMilliseconds %= (1000 * 60 * 60 * 24);
        }
        
        if (show_hours) {
          hours = Math.floor(totalMilliseconds / (1000 * 60 * 60));
          totalMilliseconds %= (1000 * 60 * 60);
        } else if ((show_months || show_days) && !show_hours) {
          // If hours are disabled but larger units are enabled, add hours to the largest enabled unit
          const extraHours = Math.floor(totalMilliseconds / (1000 * 60 * 60));
          if (show_days) {
            days += Math.floor(extraHours / 24);
          } else if (show_months) {
            months += Math.floor(extraHours / (24 * 30.44));
          }
          totalMilliseconds %= (1000 * 60 * 60);
        }
        
        if (show_minutes) {
          minutes = Math.floor(totalMilliseconds / (1000 * 60));
          totalMilliseconds %= (1000 * 60);
        } else if ((show_months || show_days || show_hours) && !show_minutes) {
          // If minutes are disabled but larger units are enabled, add minutes to the largest enabled unit
          const extraMinutes = Math.floor(totalMilliseconds / (1000 * 60));
          if (show_hours) {
            hours += Math.floor(extraMinutes / 60);
          } else if (show_days) {
            days += Math.floor(extraMinutes / (60 * 24));
          } else if (show_months) {
            months += Math.floor(extraMinutes / (60 * 24 * 30.44));
          }
          totalMilliseconds %= (1000 * 60);
        }
        
        if (show_seconds) {
          seconds = Math.floor(totalMilliseconds / 1000);
        } else if ((show_months || show_days || show_hours || show_minutes) && !show_seconds) {
          // If seconds are disabled but larger units are enabled, add seconds to the largest enabled unit
          const extraSeconds = Math.floor(totalMilliseconds / 1000);
          if (show_minutes) {
            minutes += Math.floor(extraSeconds / 60);
          } else if (show_hours) {
            hours += Math.floor(extraSeconds / (60 * 60));
          } else if (show_days) {
            days += Math.floor(extraSeconds / (60 * 60 * 24));
          } else if (show_months) {
            months += Math.floor(extraSeconds / (60 * 60 * 24 * 30.44));
          }
        }

        this.timeRemaining = { months, days, hours, minutes, seconds, total: difference };
        this.expired = false;
      } else {
        this.timeRemaining = { months: 0, days: 0, hours: 0, minutes: 0, seconds: 0, total: 0 };
        this.expired = true;
      }
      
      return this.timeRemaining;
    } catch (error) {
      console.error('TimeFlow Card: Error in updateCountdown:', error);
      return this.timeRemaining;
    }
  }

  /**
   * Calculates progress percentage
   * @param {Object} config - Card configuration
   * @param {Object} hass - Home Assistant object
   * @returns {Promise<number>} - Progress percentage (0-100)
   */
  async calculateProgress(config, hass) {
    const targetDateValue = await this.templateService.resolveValue(config.target_date, hass);
    if (!targetDateValue) return 0;
    
    // Use the helper method for consistent date parsing
    const targetDate = this.dateParser.parseISODate(targetDateValue);
    const now = Date.now();
    
    let creationDate;
    if (config.creation_date) {
      const creationDateValue = await this.templateService.resolveValue(config.creation_date, hass);
      
      if (creationDateValue) {
        // Use the helper method for consistent date parsing
        creationDate = this.dateParser.parseISODate(creationDateValue);
      } else {
        creationDate = now;
      }
    } else {
      creationDate = now; // Fallback to now if somehow no creation date
    }
    
    const totalDuration = targetDate - creationDate;
    if (totalDuration <= 0) return 100;
    
    const elapsed = now - creationDate;
    const progress = Math.min(100, Math.max(0, (elapsed / totalDuration) * 100));
    
    return this.expired ? 100 : progress;
  }

  /**
   * Gets the main display value and label
   * @param {Object} config - Card configuration
   * @returns {Object} - Object with value and label properties
   */
  getMainDisplay(config) {
    const { show_months, show_days, show_hours, show_minutes, show_seconds } = config;
    const { months, days, hours, minutes, seconds } = this.timeRemaining;
    
    if (this.expired) {
      return { value: '🎉', label: 'Completed!' };
    }
    
    // Show the largest time unit that is enabled and has a value > 0
    if (show_months && months > 0) {
      return { value: months.toString(), label: months === 1 ? 'month left' : 'months left' };
    } else if (show_days && days > 0) {
      return { value: days.toString(), label: days === 1 ? 'day left' : 'days left' };
    } else if (show_hours && hours > 0) {
      return { value: hours.toString(), label: hours === 1 ? 'hour left' : 'hours left' };
    } else if (show_minutes && minutes > 0) {
      return { value: minutes.toString(), label: minutes === 1 ? 'minute left' : 'minutes left' };
    } else if (show_seconds && seconds >= 0) {
      return { value: seconds.toString(), label: seconds === 1 ? 'second left' : 'seconds left' };
    }
    
    return { value: '0', label: 'seconds left' };
  }

  /**
   * Gets the subtitle text showing time breakdown
   * @param {Object} config - Card configuration
   * @returns {string} - Formatted subtitle text
   */
  getSubtitle(config) {
    if (this.expired) {
      const { expired_text = 'Completed! 🎉' } = config;
      return expired_text;
    }
    
    const { months, days, hours, minutes, seconds } = this.timeRemaining || { months: 0, days: 0, hours: 0, minutes: 0, seconds: 0 };
    const { show_months, show_days, show_hours, show_minutes, show_seconds } = config;
    
    const parts = [];
    
    // Add each time unit based on configuration and if value > 0
    if (show_months && months > 0) {
      parts.push({ value: months, unit: months === 1 ? 'month' : 'months' });
    }
    
    if (show_days && days > 0) {
      parts.push({ value: days, unit: days === 1 ? 'day' : 'days' });
    }
    
    if (show_hours && hours > 0) {
      parts.push({ value: hours, unit: hours === 1 ? 'hour' : 'hours' });
    }
    
    if (show_minutes && minutes > 0) {
      parts.push({ value: minutes, unit: minutes === 1 ? 'minute' : 'minutes' });
    }
    
    if (show_seconds && seconds > 0) {
      parts.push({ value: seconds, unit: seconds === 1 ? 'second' : 'seconds' });
    }
    
    // If no parts are shown or all values are 0, show the largest enabled unit
    if (parts.length === 0) {
      if (show_months) {
        parts.push({ value: months, unit: months === 1 ? 'month' : 'months' });
      } else if (show_days) {
        parts.push({ value: days, unit: days === 1 ? 'day' : 'days' });
      } else if (show_hours) {
        parts.push({ value: hours, unit: hours === 1 ? 'hour' : 'hours' });
      } else if (show_minutes) {
        parts.push({ value: minutes, unit: minutes === 1 ? 'minute' : 'minutes' });
      } else if (show_seconds) {
        parts.push({ value: seconds, unit: seconds === 1 ? 'second' : 'seconds' });
      }
    }
    
    // Count enabled units for formatting decision
    const enabledUnits = [show_months, show_days, show_hours, show_minutes, show_seconds].filter(Boolean).length;
    
    // Format based on number of enabled units
    if (enabledUnits <= 2 && parts.length > 0) {
      // Natural format for 1-2 enabled units: "1 month and 10 days"
      if (parts.length === 1) {
        return `${parts[0].value} ${parts[0].unit}`;
      } else if (parts.length === 2) {
        return `${parts[0].value} ${parts[0].unit} and ${parts[1].value} ${parts[1].unit}`;
      }
    }
    
    // Compact format for 3+ enabled units: "1mo 10d 5h"
    return parts.map(part => {
      const shortUnit = part.unit.charAt(0); // m, d, h, m, s
      return `${part.value}${shortUnit}`;
    }).join(' ') || '0s';
  }

  /**
   * Gets current time remaining
   * @returns {Object} - Time remaining object
   */
  getTimeRemaining() {
    return this.timeRemaining;
  }

  /**
   * Gets expired status
   * @returns {boolean} - Whether countdown has expired
   */
  isExpired() {
    return this.expired;
  }
}

/**
 * TemplateService - Handles Home Assistant template evaluation and caching
 * Provides efficient template processing with intelligent caching
 */
class TemplateService {
  constructor() {
    this.templateResults = new Map();
    this.templateCacheLimit = 100;
  }

  /**
   * Evaluates a Home Assistant template using the correct API
   * @param {string} template - Template string to evaluate
   * @param {Object} hass - Home Assistant object
   * @returns {Promise<*>} - Evaluated template result
   */
  async evaluateTemplate(template, hass) {
    if (!hass || !template) {
      return template;
    }

    // Check cache first
    const cacheKey = template;
    if (this.templateResults.has(cacheKey)) {
      const cached = this.templateResults.get(cacheKey);
      // Check if cache is still valid (within 5 seconds)
      if (Date.now() - cached.timestamp < 5000) {
        return cached.result;
      }
    }

    try {
      // Use callApi method like card-tools and button-card for HA templates
      const result = await hass.callApi('POST', 'template', { 
        template: template 
      });
      
      // Check if the template evaluation succeeded but returned 'unknown'
      if (result === 'unknown' || result === 'unavailable' || result === '' || result === null) {
        // Try to extract fallback from the template itself
        const fallback = this.extractFallbackFromTemplate(template);
        if (fallback && fallback !== template) {
          // Cache the fallback result
          this.templateResults.set(cacheKey, {
            result: fallback,
            timestamp: Date.now()
          });
          
          // Enforce cache size limits
          this.enforceTemplateCacheLimit();
          
          return fallback;
        }
      }
      
      // Cache the result
      this.templateResults.set(cacheKey, {
        result: result,
        timestamp: Date.now()
      });
      
      // Enforce cache size limits
      this.enforceTemplateCacheLimit();
      
      return result;
    } catch (error) {
      // Try fallback with callWS if callApi fails
      try {
        const fallbackResult = await hass.callWS({
          type: 'render_template',
          template: template
        });
        
        // Check if the template evaluation succeeded but returned 'unknown'
        if (fallbackResult === 'unknown' || fallbackResult === 'unavailable' || 
            fallbackResult === '' || fallbackResult === null) {
          // Try to extract fallback from the template itself
          const fallback = this.extractFallbackFromTemplate(template);
          if (fallback && fallback !== template) {
            // Cache the fallback result
            this.templateResults.set(cacheKey, {
              result: fallback,
              timestamp: Date.now()
            });
            
            // Enforce cache size limits
            this.enforceTemplateCacheLimit();
            
            return fallback;
          }
        }
        
        // Cache the result
        this.templateResults.set(cacheKey, {
          result: fallbackResult,
          timestamp: Date.now()
        });
        
        // Enforce cache size limits
        this.enforceTemplateCacheLimit();
        
        return fallbackResult;
      } catch (fallbackError) {
        console.error('TimeFlow Card: Template evaluation failed:', fallbackError);
        // Extract fallback value from template if it contains 'or' operator
        return this.extractFallbackFromTemplate(template);
      }
    }
  }

  /**
   * Extracts fallback value from template expressions with 'or' operator
   * @param {string} template - Template string
   * @returns {string} - Extracted fallback value
   */
  extractFallbackFromTemplate(template) {
    if (!template || typeof template !== 'string') {
      return template;
    }

    try {
      // Remove the outer {{ }} to work with the inner expression
      const innerTemplate = template.replace(/^\{\{\s*/, '').replace(/\s*\}\}$/, '').trim();
      
      // Look for patterns like "states('entity') or 'fallback'"
      const simpleOrPattern = /^(.+?)\s+or\s+['"`]([^'"`]+)['"`]$/;
      const simpleOrMatch = innerTemplate.match(simpleOrPattern);
      
      if (simpleOrMatch && simpleOrMatch[2]) {
        return simpleOrMatch[2];
      }

      // Look for chained or patterns like "states('entity1') or states('entity2') or 'fallback'"
      const chainedOrPattern = /^(.+?)\s+or\s+(.+?)\s+or\s+['"`]([^'"`]+)['"`]$/;
      const chainedMatch = innerTemplate.match(chainedOrPattern);
      
      if (chainedMatch && chainedMatch[3]) {
        return chainedMatch[3];
      }

      // Look for conditional patterns like "'value' if condition else 'fallback'"
      const conditionalPattern = /^['"`]([^'"`]+)['"`]\s+if\s+(.+?)\s+else\s+['"`]([^'"`]+)['"`]$/;
      const conditionalMatch = innerTemplate.match(conditionalPattern);
      
      if (conditionalMatch && conditionalMatch[3]) {
        return conditionalMatch[3];
      }

      // Look for reverse conditional patterns like "condition if test else 'fallback'"
      const reverseConditionalPattern = /^(.+?)\s+if\s+(.+?)\s+else\s+['"`]([^'"`]+)['"`]$/;
      const reverseMatch = innerTemplate.match(reverseConditionalPattern);
      
      if (reverseMatch && reverseMatch[3]) {
        return reverseMatch[3];
      }

      // If no fallback pattern found, return a helpful message
      return 'Unavailable';
    } catch (error) {
      console.warn('TimeFlow Card: Error extracting fallback from template:', error);
      return 'Template Error';
    }
  }

  /**
   * Detects if a value contains Home Assistant templates
   * @param {*} value - Value to check
   * @returns {boolean} - Whether the value is a template
   */
  isTemplate(value) {
    return typeof value === 'string' && 
           value.includes('{{') && 
           value.includes('}}');
  }

  /**
   * Enhanced value resolver that handles entities, templates, and plain strings
   * @param {*} value - Value to resolve
   * @param {Object} hass - Home Assistant object
   * @returns {Promise<*>} - Resolved value
   */
  async resolveValue(value, hass) {
    if (!value) return null;
    
    // Handle templates first
    if (this.isTemplate(value)) {
      const result = await this.evaluateTemplate(value, hass);
      return result;
    }
    
    // Handle entity references
    if (typeof value === 'string' && value.includes('.') && hass && hass.states[value]) {
      const entity = hass.states[value];
      // Check if entity state is unknown/unavailable
      if (entity.state === 'unknown' || entity.state === 'unavailable') {
        return null;
      }
      
      // For entity timestamps, strip timezone info to treat as local time
      // This provides more intuitive behavior for users
      let entityValue = entity.state;
      if (typeof entityValue === 'string' && entityValue.includes('T')) {
        // Remove timezone information (+XX:XX, -XX:XX, Z) from entity values
        // This ensures entity timestamps are always treated as local time
        entityValue = entityValue.replace(/([+-]\d{2}:\d{2}|Z)$/, '');
      }
      
      return entityValue;
    }
    
    // Return plain string/value
    return value;
  }

  /**
   * Clears template cache when entities change
   */
  clearTemplateCache() {
    this.templateResults.clear();
  }

  /**
   * Enforces template cache size limits to prevent memory growth
   */
  enforceTemplateCacheLimit() {
    if (this.templateResults.size <= this.templateCacheLimit) {
      return;
    }

    // Convert to array and sort by timestamp (oldest first)
    const cacheEntries = Array.from(this.templateResults.entries())
      .sort((a, b) => a[1].timestamp - b[1].timestamp);

    // Remove oldest entries until we're under the limit
    const entriesToRemove = cacheEntries.length - this.templateCacheLimit;
    for (let i = 0; i < entriesToRemove; i++) {
      this.templateResults.delete(cacheEntries[i][0]);
    }
  }

  /**
   * Checks if the current config contains any templates
   * @param {Object} config - Configuration object
   * @returns {boolean} - Whether config contains templates
   */
  hasTemplatesInConfig(config) {
    if (!config) return false;
    
    // Check common template-enabled properties
    const templateProperties = [
      'target_date', 'creation_date', 'title', 'subtitle',
      'color', 'background_color', 'progress_color', 'primary_color', 'secondary_color'
    ];
    
    return templateProperties.some(prop => 
      config[prop] && this.isTemplate(config[prop])
    );
  }

  /**
   * Escapes HTML special characters to prevent XSS and ensure proper display
   * @param {*} text - Text to escape
   * @returns {string} - Escaped text
   */
  escapeHtml(text) {
    if (text == null || text === undefined) return '';
    return String(text)
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#39;');
  }
}

/**
 * ConfigValidator - Comprehensive input validation for TimeFlow Card configuration
 * Ensures security, type safety, and data integrity
 */
class ConfigValidator {
  /**
   * Comprehensive input validation for configuration
   * @param {Object} config - Configuration object to validate
   * @throws {Error} - If validation fails
   */
  static validateConfig(config) {
    const errors = [];
    
    // Validate target_date
    if (config.target_date) {
      if (!this.isValidDateInput(config.target_date)) {
        errors.push('Invalid target_date format. Use ISO date string, entity ID, or template.');
      }
    }
    
    // Validate creation_date if provided
    if (config.creation_date && !this.isValidDateInput(config.creation_date)) {
      errors.push('Invalid creation_date format. Use ISO date string, entity ID, or template.');
    }
    
    // Validate colors
    const colorFields = ['color', 'background_color', 'progress_color'];
    colorFields.forEach(field => {
      if (config[field] && !this.isValidColorInput(config[field])) {
        errors.push(`Invalid ${field} format. Use hex, rgb, hsl, CSS color name, entity ID, or template.`);
      }
    });
    
    // Validate dimensions
    const dimensionFields = ['width', 'height', 'icon_size'];
    dimensionFields.forEach(field => {
      if (config[field] && !this.isValidDimensionInput(config[field])) {
        errors.push(`Invalid ${field} format. Use pixel values, percentages, or CSS units.`);
      }
    });
    
    // Validate aspect_ratio
    if (config.aspect_ratio && !this.isValidAspectRatioInput(config.aspect_ratio)) {
      errors.push('Invalid aspect_ratio format. Use format like "16/9" or "4/3".');
    }
    
    // Validate stroke_width
    if (config.stroke_width !== undefined && !this.isValidNumberInput(config.stroke_width, 1, 50)) {
      errors.push('Invalid stroke_width. Must be a number between 1 and 50.');
    }
    
    // Validate boolean fields
    const booleanFields = ['show_months', 'show_days', 'show_hours', 'show_minutes', 'show_seconds', 'expired_animation'];
    booleanFields.forEach(field => {
      if (config[field] !== undefined && !this.isValidBooleanInput(config[field])) {
        errors.push(`Invalid ${field}. Must be true or false.`);
      }
    });
    
    // Validate text fields for XSS prevention
    const textFields = ['title', 'subtitle', 'expired_text'];
    textFields.forEach(field => {
      if (config[field] && !this.isValidTextInput(config[field])) {
        errors.push(`Invalid ${field}. Contains potentially unsafe content.`);
      }
    });
    
    // Validate styles object
    if (config.styles && !this.isValidStylesInput(config.styles)) {
      errors.push('Invalid styles object. Must contain valid style arrays for card, title, subtitle, or progress_circle.');
    }
    
    // Throw error if validation fails
    if (errors.length > 0) {
      throw new Error(`Configuration validation failed:\n${errors.join('\n')}`);
    }
  }
  
  /**
   * Validates date input (string, entity, or template)
   * @param {*} value - Value to validate
   * @returns {boolean} - Whether the value is valid
   */
  static isValidDateInput(value) {
    if (!value) return false;
    
    // Allow templates
    if (this.isTemplate(value)) return true;
    
    // Allow entity IDs
    if (typeof value === 'string' && value.includes('.')) return true;
    
    // Validate date string format
    if (typeof value === 'string') {
      try {
        const date = new Date(value);
        return !isNaN(date.getTime());
      } catch (e) {
        return false;
      }
    }
    
    return false;
  }
  
  /**
   * Validates color input (color value, entity, or template)
   * @param {*} value - Value to validate
   * @returns {boolean} - Whether the value is valid
   */
  static isValidColorInput(value) {
    if (!value) return false;
    
    // Allow templates and entities
    if (this.isTemplate(value) || (typeof value === 'string' && value.includes('.'))) return true;
    
    if (typeof value !== 'string') return false;
    
    // Check hex colors
    if (/^#([0-9A-F]{3}){1,2}$/i.test(value)) return true;
    
    // Check rgb/rgba
    if (/^rgba?\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*(,\s*[\d.]+\s*)?\)$/i.test(value)) return true;
    
    // Check hsl/hsla
    if (/^hsla?\(\s*\d+\s*,\s*\d+%\s*,\s*\d+%\s*(,\s*[\d.]+\s*)?\)$/i.test(value)) return true;
    
    // Check CSS color names (expanded list)
    const cssColors = [
      'red', 'blue', 'green', 'yellow', 'orange', 'purple', 'pink', 'brown', 'black', 'white', 'gray', 'grey',
      'cyan', 'magenta', 'lime', 'maroon', 'navy', 'olive', 'teal', 'silver', 'gold', 'indigo', 'violet',
      'transparent', 'currentColor', 'inherit', 'initial', 'unset'
    ];
    
    return cssColors.includes(value.toLowerCase());
  }
  
  /**
   * Validates dimension input (dimension value, entity, or template)
   * @param {*} value - Value to validate
   * @returns {boolean} - Whether the value is valid
   */
  static isValidDimensionInput(value) {
    if (!value) return false;
    
    // Allow templates and entities
    if (this.isTemplate(value) || (typeof value === 'string' && value.includes('.'))) return true;
    
    // Allow numbers
    if (typeof value === 'number') return true;
    
    if (typeof value !== 'string') return false;
    
    // Check pixel values (0-10000px)
    const pxMatch = value.match(/^(\d+(?:\.\d+)?)px$/i);
    if (pxMatch) {
      const px = parseFloat(pxMatch[1]);
      return px >= 0 && px <= 10000;
    }
    
    // Check percentage values (0-1000%)
    const percentMatch = value.match(/^(\d+(?:\.\d+)?)%$/i);
    if (percentMatch) {
      const percent = parseFloat(percentMatch[1]);
      return percent >= 0 && percent <= 1000;
    }
    
    // Check other valid CSS units
    const validUnits = ['em', 'rem', 'vh', 'vw', 'vmin', 'vmax', 'ch', 'ex'];
    for (const unit of validUnits) {
      const regex = new RegExp(`^(\\d+(?:\\.\\d+)?)${unit}$`, 'i');
      const match = value.match(regex);
      if (match) {
        const unitValue = parseFloat(match[1]);
        return unitValue >= 0 && unitValue <= 1000; // Reasonable bounds
      }
    }
    
    // Check for 'auto', 'fit-content', etc.
    const validKeywords = ['auto', 'fit-content', 'min-content', 'max-content'];
    return validKeywords.includes(value.toLowerCase());
  }
  
  /**
   * Validates aspect ratio input
   * @param {*} value - Value to validate
   * @returns {boolean} - Whether the value is valid
   */
  static isValidAspectRatioInput(value) {
    if (!value) return false;
    
    // Allow templates and entities
    if (this.isTemplate(value) || (typeof value === 'string' && value.includes('.'))) return true;
    
    if (typeof value !== 'string') return false;
    
    // Check aspect ratio format: number/number
    const aspectMatch = value.match(/^(\d+(?:\.\d+)?)\/(\d+(?:\.\d+)?)$/);
    if (aspectMatch) {
      const width = parseFloat(aspectMatch[1]);
      const height = parseFloat(aspectMatch[2]);
      return width > 0 && height > 0 && width <= 20 && height <= 20; // Reasonable bounds
    }
    
    return false;
  }
  
  /**
   * Validates number input with optional bounds
   * @param {*} value - Value to validate
   * @param {number} min - Minimum allowed value
   * @param {number} max - Maximum allowed value
   * @returns {boolean} - Whether the value is valid
   */
  static isValidNumberInput(value, min = -Infinity, max = Infinity) {
    if (value === undefined || value === null) return false;
    
    // Allow templates and entities
    if (typeof value === 'string') {
      if (this.isTemplate(value) || value.includes('.')) return true;
      // Try to parse string numbers
      const parsed = parseFloat(value);
      return !isNaN(parsed) && parsed >= min && parsed <= max;
    }
    
    return typeof value === 'number' && !isNaN(value) && value >= min && value <= max;
  }
  
  /**
   * Validates boolean input
   * @param {*} value - Value to validate
   * @returns {boolean} - Whether the value is valid
   */
  static isValidBooleanInput(value) {
    return typeof value === 'boolean';
  }
  
  /**
   * Validates text input for XSS prevention
   * @param {*} value - Value to validate
   * @returns {boolean} - Whether the value is valid
   */
  static isValidTextInput(value) {
    if (!value) return true;
    
    // Allow templates and entities
    if (this.isTemplate(value) || (typeof value === 'string' && value.includes('.'))) return true;
    
    if (typeof value !== 'string') return false;
    
    // Check for potentially dangerous content
    const dangerousPatterns = [
      /<script/i,
      /javascript:/i,
      /vbscript:/i,
      /on\w+\s*=/i, // Event handlers like onclick=
      /<iframe/i,
      /<object/i,
      /<embed/i,
      /<form/i
    ];
    
    return !dangerousPatterns.some(pattern => pattern.test(value));
  }
  
  /**
   * Validates styles object structure
   * @param {*} styles - Styles object to validate
   * @returns {boolean} - Whether the styles are valid
   */
  static isValidStylesInput(styles) {
    if (!styles || typeof styles !== 'object') return false;
    
    const validStyleKeys = ['card', 'title', 'subtitle', 'progress_circle'];
    
    // Check that all keys are valid
    const styleKeys = Object.keys(styles);
    if (!styleKeys.every(key => validStyleKeys.includes(key))) return false;
    
    // Check that all values are arrays
    return styleKeys.every(key => Array.isArray(styles[key]));
  }

  /**
   * Detects if a value contains Home Assistant templates
   * @param {*} value - Value to check
   * @returns {boolean} - Whether the value is a template
   */
  static isTemplate(value) {
    return typeof value === 'string' && 
           value.includes('{{') && 
           value.includes('}}');
  }
}

/**
 * DateParser - Enhanced date parsing utility with three-tier fallback system
 * Handles cross-browser compatibility and edge cases for date string parsing
 */
class DateParser {
  /**
   * Main entry point for date parsing with hybrid approach
   * @param {string} dateString - ISO date string to parse
   * @returns {number} - Unix timestamp in milliseconds
   */
  static parseISODate(dateString) {
    try {
      // Fast path: Use native parsing for most cases
      const nativeResult = new Date(dateString);
      if (!isNaN(nativeResult.getTime()) && this.isValidDateResult(nativeResult, dateString)) {
        return nativeResult.getTime();
      }
      
      // Enhanced path: Use robust parsing for edge cases
      return this.parseISODateRobust(dateString);
    } catch (e) {
      console.warn('TimeFlow Card: Date parsing error, using fallback:', e);
      return this.parseISODateFallback(dateString);
    }
  }

  /**
   * Validates that a parsed date result is reasonable
   * @param {Date} dateObj - Parsed date object
   * @param {string} originalString - Original date string
   * @returns {boolean} - Whether the date is valid
   */
  static isValidDateResult(dateObj, originalString) {
    const timestamp = dateObj.getTime();
    
    // Check for reasonable date range (1970-2100)
    const minTimestamp = new Date('1970-01-01').getTime();
    const maxTimestamp = new Date('2100-12-31').getTime();
    
    if (timestamp < minTimestamp || timestamp > maxTimestamp) {
      return false;
    }
    
    // Check for February 29th in non-leap years
    if (typeof originalString === 'string' && originalString.includes('02-29')) {
      const year = dateObj.getFullYear();
      if (!this.isLeapYear(year)) {
        return false;
      }
    }
    
    return true;
  }

  /**
   * Check if a year is a leap year
   * @param {number} year - Year to check
   * @returns {boolean} - Whether the year is a leap year
   */
  static isLeapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || (year % 400 === 0);
  }

  /**
   * Robust date parsing using Intl.DateTimeFormat for edge cases
   * @param {string} dateString - Date string to parse
   * @returns {number} - Unix timestamp
   */
  static parseISODateRobust(dateString) {
    try {
      // Check for Intl support
      if (typeof Intl !== 'undefined' && Intl.DateTimeFormat) {
        return this.parseWithIntl(dateString);
      }
      
      // Fallback to enhanced manual parsing
      return this.parseISODateManual(dateString);
    } catch (error) {
      console.warn('TimeFlow Card: Robust parsing failed, using manual fallback:', error);
      return this.parseISODateManual(dateString);
    }
  }

  /**
   * Parse date using Intl.DateTimeFormat for maximum compatibility
   * @param {string} dateString - Date string to parse
   * @returns {number} - Unix timestamp
   */
  static parseWithIntl(dateString) {
    try {
      // First try to parse normally to get a base date
      const baseDate = new Date(dateString);
      if (isNaN(baseDate.getTime())) {
        throw new Error('Base date parsing failed');
      }
      
      // Use Intl to format and re-parse for consistency
      const formatter = new Intl.DateTimeFormat('en-CA', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit',
        timeZone: 'UTC'
      });
      
      const parts = formatter.formatToParts(baseDate);
      const partsObj = {};
      parts.forEach(part => {
        if (part.type !== 'literal') {
          partsObj[part.type] = part.value;
        }
      });
      
      // Construct date from parsed parts for consistency
      const reconstructed = new Date(
        partsObj.year || 1970,
        (partsObj.month || 1) - 1,
        partsObj.day || 1,
        partsObj.hour || 0,
        partsObj.minute || 0,
        partsObj.second || 0
      );
      
      return reconstructed.getTime();
    } catch (error) {
      // If Intl parsing fails, fall back to manual parsing
      throw error;
    }
  }

  /**
   * Enhanced manual parsing with better error handling
   * @param {string} dateString - Date string to parse
   * @returns {number} - Unix timestamp
   */
  static parseISODateManual(dateString) {
    if (typeof dateString === 'string' && dateString.includes('T')) {
      // Check if the string contains timezone information (Z, +XX:XX, -XX:XX)
      const hasTimezone = /[+-]\d{2}:\d{2}$|Z$/.test(dateString);
      
      if (hasTimezone) {
        // For ISO strings with timezone info, use native Date parsing to preserve timezone
        return new Date(dateString).getTime();
      } else {
        // For timezone-less ISO strings, use manual parsing for cross-platform consistency
        const [datePart, timePart] = dateString.split('T');
        const [year, month, day] = datePart.split('-').map(Number);
        
        // Validate date components
        if (!this.isValidDateComponents(year, month, day)) {
          throw new Error('Invalid date components');
        }
        
        if (timePart && timePart.includes(':')) {
          const [hour, minute, second] = timePart.split(':').map(parseFloat);
          
          // Validate time components
          if (!this.isValidTimeComponents(hour, minute, second)) {
            throw new Error('Invalid time components');
          }
          
          return new Date(year, month - 1, day, hour, minute, second || 0).getTime();
        } else {
          return new Date(year, month - 1, day).getTime();
        }
      }
    } else {
      // Fallback to regular parsing for other formats
      return new Date(dateString).getTime();
    }
  }

  /**
   * Validates date components
   * @param {number} year - Year component
   * @param {number} month - Month component (1-12)
   * @param {number} day - Day component
   * @returns {boolean} - Whether components are valid
   */
  static isValidDateComponents(year, month, day) {
    if (isNaN(year) || isNaN(month) || isNaN(day)) return false;
    if (year < 1970 || year > 2100) return false;
    if (month < 1 || month > 12) return false;
    if (day < 1 || day > 31) return false;
    
    // Check days in month
    const daysInMonth = [31, this.isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    if (day > daysInMonth[month - 1]) return false;
    
    return true;
  }

  /**
   * Validates time components
   * @param {number} hour - Hour component
   * @param {number} minute - Minute component
   * @param {number} second - Second component
   * @returns {boolean} - Whether components are valid
   */
  static isValidTimeComponents(hour, minute, second) {
    const h = parseInt(hour);
    const m = parseInt(minute);
    const s = parseInt(second);
    
    if (isNaN(h) || isNaN(m) || isNaN(s)) return false;
    if (h < 0 || h > 23) return false;
    if (m < 0 || m > 59) return false;
    if (s < 0 || s > 59) return false;
    
    return true;
  }

  /**
   * Final fallback parsing method
   * @param {string} dateString - Date string to parse
   * @returns {number} - Unix timestamp
   */
  static parseISODateFallback(dateString) {
    try {
      const timestamp = Date.parse(dateString);
      if (!isNaN(timestamp)) {
        return timestamp;
      }
      
      // Last resort: return current time with warning
      console.warn('TimeFlow Card: Could not parse date, using current time as fallback:', dateString);
      return Date.now();
    } catch (error) {
      console.error('TimeFlow Card: All date parsing methods failed:', error);
      return Date.now();
    }
  }
}

/**
 * TimeFlowCard - Main card component with modular architecture
 * Orchestrates all modules and provides clean separation of concerns
 */
class TimeFlowCard extends HTMLElement {
  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
    this._config = {};
    this._hass = null;
    this._interval = null;
    this._updateScheduled = false;
    this._domElements = null;
    
    // Initialize modular services
    this.templateService = new TemplateService();
    this.countdownService = new CountdownService(this.templateService, DateParser);
    this.styleManager = new StyleManager();
    this.accessibilityManager = new AccessibilityManager();
    
    // Performance cache
    this._cache = {
      lastConfigHash: null,
      lastEntityStates: new Map(),
      templateWatchers: new Map(),
      parsedTargetDate: null,
      parsedCreationDate: null
    };
    
    // Error handling
    this._errorState = null;
  }

  static getStubConfig() {
    return {
      type: 'timeflow-card',
      target_date: '2024-12-31T23:59:59',
      title: 'New Year Countdown',
      show_days: true,
      show_hours: true,
      show_minutes: true,
      show_seconds: true
    };
  }

  setConfig(config) {
    try {
      // Validate configuration using modular validator
      ConfigValidator.validateConfig(config);
      
      this._config = { ...config };
      this._errorState = null;
      
      // Clear caches when config changes
      this.templateService.clearTemplateCache();
      this.styleManager.clearCache();
      this._clearPerformanceCache();
      
      // Re-apply card-mod styles when config changes
      setTimeout(() => this._applyCardMod(), 0);
    } catch (error) {
      this._errorState = error.message;
      console.error('TimeFlow Card: Configuration error:', error);
      this._renderError();
    }
  }

  set hass(hass) {
    const oldHass = this._hass;
    this._hass = hass;
    
    // Clear template cache when hass changes or entities update
    if (hass && oldHass !== hass) {
      this.templateService.clearTemplateCache();
      this._hasEntitiesChanged(oldHass, hass);
    }
  }

  connectedCallback() {
    (async () => await this._startTimer())();
    this._applyCardMod();
    this._setupAccessibility();
  }

  disconnectedCallback() {
    this._stopTimer();
    this._cleanup();
  }

  /**
   * Sets up accessibility features
   */
  _setupAccessibility() {
    this.accessibilityManager.setContext(
      this._config,
      this.countdownService,
      () => this._refreshCard()
    );
  }

  /**
   * Refreshes the card (called by accessibility manager)
   */
  _refreshCard() {
    this.templateService.clearTemplateCache();
    this.render();
  }

  /**
   * Cleans up resources
   */
  _cleanup() {
    this.accessibilityManager.cleanup();
    
    // Clear all caches to prevent memory leaks
    this.templateService.clearTemplateCache();
    this._clearPerformanceCache();
    
    // Clear cached DOM references
    this._domElements = null;
    
    // Cancel any pending animation frames
    if (this._updateScheduled) {
      this._updateScheduled = false;
    }
    
    // Clear error state
    this._errorState = null;
  }

  /**
   * Clears performance cache
   */
  _clearPerformanceCache() {
    this._cache.lastConfigHash = null;
    this._cache.lastEntityStates.clear();
    this._cache.templateWatchers.clear();
    this._cache.parsedTargetDate = null;
    this._cache.parsedCreationDate = null;
  }

  /**
   * Checks if entities have changed
   * @param {Object} oldHass - Previous hass object
   * @param {Object} newHass - New hass object
   * @returns {boolean} - Whether entities changed
   */
  _hasEntitiesChanged(oldHass, newHass) {
    if (!oldHass || !newHass) return true;
    
    // Check if any relevant entities have changed
    const templateProperties = ['target_date', 'creation_date', 'title', 'subtitle', 'color', 'background_color', 'progress_color'];
    
    return templateProperties.some(prop => {
      const value = this._config[prop];
      if (typeof value === 'string' && value.includes('.')) {
        // This is an entity
        const oldState = oldHass.states[value];
        const newState = newHass.states[value];
        return !oldState || !newState || oldState.state !== newState.state;
      }
      return false;
    });
  }

  /**
   * Performance optimization: detect config changes
   */
  _hasConfigChanged() {
    const configHash = JSON.stringify({
      ...this._config,
      target_date: typeof this._config.target_date === 'string' && this._config.target_date.includes('.') ? 'entity' : this._config.target_date,
      creation_date: typeof this._config.creation_date === 'string' && this._config.creation_date.includes('.') ? 'entity' : this._config.creation_date
    });
    
    if (this._cache.lastConfigHash !== configHash) {
      this._cache.lastConfigHash = configHash;
      return true;
    }
    return false;
  }

  /**
   * Card-mod support
   */
  _applyCardMod() {
    if (!this._config || !this._config.card_mod) return;
    
    // Wait for card-mod to be available and apply styles
    customElements.whenDefined("card-mod").then(() => {
      const cardMod = customElements.get("card-mod");
      if (cardMod && cardMod.applyToElement) {
        cardMod.applyToElement(this, this._config.card_mod, {});
      }
    }).catch(() => {
      // Card-mod not available, silently continue
    });
  }

  async _startTimer() {
    this._stopTimer();
    await this._updateCountdown(); // Make sure initial countdown calculation completes
    this._interval = setInterval(async () => {
      await this._updateCountdown();
    }, 1000);
  }

  _stopTimer() {
    if (this._interval) {
      clearInterval(this._interval);
      this._interval = null;
    }
  }

  /**
   * Performance optimization: schedule updates with RAF
   */
  _scheduleUpdate() {
    if (!this._updateScheduled) {
      this._updateScheduled = true;
      requestAnimationFrame(async () => {
        this._updateScheduled = false;
        await this.render();
      });
    }
  }

  async _updateCountdown() {
    try {
      await this.countdownService.updateCountdown(this._config, this._hass);
      this._scheduleUpdate();
    } catch (error) {
      console.error('TimeFlow Card: Error in updateCountdown:', error);
    }
  }

  /**
   * Resolves template-based configuration properties
   */
  async _resolveTemplateProperties() {
    const resolvedConfig = { ...this._config };
    
    // Properties that support templating
    const templateProperties = [
      'title', 'subtitle', 'color', 'background_color', 'progress_color', 
      'primary_color', 'secondary_color', 'target_date', 'creation_date'
    ];
    
    for (const prop of templateProperties) {
      if (resolvedConfig[prop]) {
        try {
          resolvedConfig[prop] = await this.templateService.resolveValue(resolvedConfig[prop], this._hass);
        } catch (error) {
          console.error(`TimeFlow Card: Failed to resolve property "${prop}":`, error);
          // Keep original value as fallback
        }
      }
    }
    
    return resolvedConfig;
  }

  async render() {
    if (this._errorState) {
      this._renderError();
      return;
    }

    // Check if we need to rebuild DOM or just update content
    if (!this._domElements || this._hasConfigChanged()) {
      await this._initializeDOM();
    } else {
      await this._updateContent();
    }
  }

  /**
   * Renders error state
   */
  _renderError() {
    this.shadowRoot.innerHTML = `
      <style>
        .error {
          display: flex;
          align-items: center;
          justify-content: center;
          padding: 20px;
          background: #f44336;
          color: white;
          border-radius: 8px;
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
        }
        .error-title {
          font-weight: bold;
          margin-bottom: 8px;
        }
        .error-message {
          font-size: 0.9em;
          opacity: 0.9;
        }
      </style>
      <ha-card class="error">
        <div>
          <div class="error-title">TimeFlow Card Configuration Error</div>
          <div class="error-message">${this._errorState}</div>
        </div>
      </ha-card>
    `;
  }

  /**
   * Performance optimization: Initialize DOM structure only when needed
   */
  async _initializeDOM() {
    // Resolve any template properties first
    const resolvedConfig = await this._resolveTemplateProperties();
    
    const {
      title = 'Countdown Timer',
      color = '#ffffff',
      background_color,
      progress_color,
      expired_animation = true,
      width = null,
      height = null,
      aspect_ratio = '2/1',
      icon_size = '100px',
      stroke_width = 15,
    } = resolvedConfig;

    const bgColor = background_color || '#1976d2';
    const progressColor = progress_color || '#4CAF50';

    // Calculate proportional sizes using style manager
    const proportionalSizes = this.styleManager.calculateProportionalSizes(width, height, aspect_ratio);
    const dynamicIconSize = this.styleManager.calculateDynamicIconSize(width, height, aspect_ratio, icon_size);
    const dynamicStrokeWidth = this.styleManager.calculateDynamicStrokeWidth(dynamicIconSize, stroke_width);

    // Pre-calculate values that need async resolution
    const currentProgress = await this.countdownService.calculateProgress(this._config, this._hass);
    const subtitleText = this.countdownService.getSubtitle(this._config);
    
    // Generate accessibility IDs
    const ids = this.accessibilityManager.generateAccessibilityIds();

    // Calculate card dimensions dynamically
    const cardStyles = this.styleManager.generateCardDimensionStyles(width, height, aspect_ratio);

    this.shadowRoot.innerHTML = `
      <style>
        :host {
          display: block;
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
          
          /* CSS Variables for dynamic theming */
          --timeflow-card-background-color: ${bgColor};
          --timeflow-card-text-color: ${color};
          --timeflow-card-progress-color: ${progressColor};
          --timeflow-card-icon-size: ${dynamicIconSize}px;
          --timeflow-card-stroke-width: ${dynamicStrokeWidth};
        }
        
        ha-card {
          display: flex;
          flex-direction: column;
          padding: 0;
          border-radius: 22px;
          position: relative;
          overflow: hidden;
          background: var(--timeflow-card-background-color);
          color: var(--timeflow-card-text-color);
          box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
          border: none;
          ${cardStyles.join(';\n          ')};
        }
        
        .card-content {
          display: flex;
          flex-direction: column;
          justify-content: space-between;
          padding: 20px;
          height: 100%;
        }
        
        .header {
          display: flex;
          justify-content: space-between;
          align-items: flex-start;
          margin-bottom: 0;
        }
        
        .title-section {
          flex: 1;
          display: flex;
          flex-direction: column;
          gap: 2px;
        }
        
        .title {
          font-size: ${proportionalSizes.titleSize}rem;
          font-weight: 500;
          margin: 0;
          opacity: 0.9;
          line-height: 1.3;
          letter-spacing: -0.01em;
        }
        
        .subtitle {
          font-size: ${proportionalSizes.subtitleSize}rem;
          opacity: 0.65;
          margin: 0;
          font-weight: 400;
          line-height: 1.2;
        }
        
        .progress-section {
          flex-shrink: 0;
          margin-left: auto;
        }
        
        .content {
          display: flex;
          align-items: flex-end;
          justify-content: flex-end;
          margin-top: auto;
          padding-top: 12px;
        }
        
        .expired {
          ${expired_animation ? 'animation: celebration 0.8s ease-in-out;' : ''}
        }
        
        ${expired_animation ? `
        @keyframes celebration {
          0% { transform: scale(1); }
          50% { transform: scale(1.05); }
          100% { transform: scale(1); }
        }` : ''}
        
        .progress-circle {
          opacity: 0.9;
        }
        
        /* Dark mode support */
        @media (prefers-color-scheme: dark) {
          ha-card {
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
          }
        }
        
        /* Accessibility enhancements */
        .sr-only {
          position: absolute;
          width: 1px;
          height: 1px;
          padding: 0;
          margin: -1px;
          overflow: hidden;
          clip: rect(0, 0, 0, 0);
          white-space: nowrap;
          border: 0;
        }
        
        .live-region {
          position: absolute;
          left: -10000px;
          width: 1px;
          height: 1px;
          overflow: hidden;
        }
        
        /* Focus indicators */
        ha-card:focus-within {
          outline: 2px solid var(--primary-color, #03A9F4);
          outline-offset: 2px;
        }
        
        .progress-section:focus-within {
          border-radius: 50%;
        }
      </style>
      
      <ha-card 
        class="timeflow-card ${this.countdownService.isExpired() && expired_animation ? 'expired' : ''}"
        id="${ids.cardId}"
        role="timer"
        aria-labelledby="${ids.titleId}"
        aria-describedby="${ids.subtitleId} ${ids.progressId}"
        tabindex="0"
      >
        <div class="card-content">
          ${this.accessibilityManager.generateAccessibilityHTML(ids, this.countdownService.isExpired(), subtitleText, currentProgress)}
          
          <header class="header">
            <div class="title-section">
              <h2 class="title" id="${ids.titleId}">${this.templateService.escapeHtml(title || 'Countdown Timer')}</h2>
              <p class="subtitle" id="${ids.subtitleId}" aria-live="polite">${this.templateService.escapeHtml(subtitleText || '0s')}</p>
            </div>
          </header>
          
          <div class="content">
            <div class="progress-section" role="region" aria-labelledby="${ids.progressId}">
              <progress-circle
                class="progress-circle"
                progress="${currentProgress}"
                color="${progressColor}"
                size="${dynamicIconSize}"
                stroke-width="${dynamicStrokeWidth}"
                role="img"
                aria-label="Timer progress indicator"
                aria-describedby="${ids.progressId}"
              ></progress-circle>
            </div>
          </div>
        </div>
      </ha-card>
    `;

    // Cache DOM elements for selective updates
    this._domElements = {
      haCard: this.shadowRoot.querySelector('ha-card'),
      cardContent: this.shadowRoot.querySelector('.card-content'),
      title: this.shadowRoot.querySelector('.title'),
      subtitle: this.shadowRoot.querySelector('.subtitle'),
      progressCircle: this.shadowRoot.querySelector('progress-circle'),
      liveRegion: this.shadowRoot.querySelector(`#${ids.liveRegionId}`),
      progressDescription: this.shadowRoot.querySelector(`#${ids.progressId}`)
    };
    
    setTimeout(() => {
      this._updateDisplayWithAccessibility();
      this._applyNativeStyles();
      this._applyCardMod();
      this._setupKeyboardNavigation();
    }, 0);
  }

  /**
   * Apply native styles from config to DOM elements
   */
  _applyNativeStyles() {
    if (!this._domElements || !this._config.styles) return;

    const processedStyles = this.styleManager.buildStylesObject(this._config);

    try {
      // Apply card styles to card-content
      if (processedStyles.card && this._domElements.cardContent) {
        this._domElements.cardContent.style.cssText += '; ' + processedStyles.card;
      }

      // Apply title styles
      if (processedStyles.title && this._domElements.title) {
        this._domElements.title.style.cssText += '; ' + processedStyles.title;
      }

      // Apply subtitle styles
      if (processedStyles.subtitle && this._domElements.subtitle) {
        this._domElements.subtitle.style.cssText += '; ' + processedStyles.subtitle;
      }

      // Apply progress circle styles
      if (processedStyles.progress_circle && this._domElements.progressCircle) {
        this._domElements.progressCircle.style.cssText += '; ' + processedStyles.progress_circle;
      }
    } catch (error) {
      console.warn('TimeFlow Card: Error applying native styles:', error);
    }
  }

  /**
   * Performance optimization: Update only content that changes
   */
  async _updateContent() {
    if (!this._domElements) return;

    // Resolve any template properties first
    const resolvedConfig = await this._resolveTemplateProperties();
    const { title = 'Countdown Timer' } = resolvedConfig;

    // Update title - always show original title
    if (this._domElements.title && this._domElements.title.textContent !== title) {
      this._domElements.title.textContent = title;
    }

    // Update subtitle
    const subtitleText = this.countdownService.getSubtitle(this._config);
    if (this._domElements.subtitle && this._domElements.subtitle.textContent !== subtitleText) {
      this._domElements.subtitle.textContent = subtitleText;
    }

    // Update progress circle
    const progress = await this.countdownService.calculateProgress(this._config, this._hass);
    if (this._domElements.progressCircle) {
      this._domElements.progressCircle.setAttribute('progress', progress);
    }

    // Update expired state
    if (this._domElements.haCard) {
      const { expired_animation = true } = this._config;
      this._domElements.haCard.classList.toggle('expired', this.countdownService.isExpired() && expired_animation);
    }
  }

  /**
   * Sets up keyboard navigation
   */
  _setupKeyboardNavigation() {
    this.accessibilityManager.setupCardKeyboardNavigation(this.shadowRoot, this._domElements);
  }

  /**
   * Enhanced progress updates for accessibility
   */
  async _updateDisplayWithAccessibility() {
    await this._updateContent();
    
    // Update accessibility attributes
    const progress = await this.countdownService.calculateProgress(this._config, this._hass);
    const subtitle = this.countdownService.getSubtitle(this._config);
    
    this.accessibilityManager.updateAccessibilityAttributes(progress, subtitle);
  }

  getCardSize() {
    // Dynamic card size based on aspect ratio and dimensions
    const { aspect_ratio = '2/1', height } = this._config;
    
    if (height) {
      // If explicit height is set, calculate size based on pixels
      const heightValue = parseInt(height);
      if (heightValue <= 100) return 1;
      if (heightValue <= 150) return 2;
      if (heightValue <= 200) return 3;
      return 4;
    }
    
    // Calculate based on aspect ratio
    if (aspect_ratio) {
      const [width, height] = aspect_ratio.split('/').map(Number);
      const ratio = height / width;
      
      // Taller cards need more rows
      if (ratio >= 1.5) return 4; // Square-ish or tall
      if (ratio >= 1) return 3;   // Square
      if (ratio >= 0.75) return 2; // Slightly wide
      return 2; // Wide cards
    }
    
    return 3; // Default
  }

  static get version() {
    return '1.2.0';
  }
}

/**
 * TimeFlow Card - Entry point for modular architecture
 * Registers components and exposes the card to Home Assistant
 */
// Register custom elements
customElements.define('progress-circle', ProgressCircle);
customElements.define('timeflow-card', TimeFlowCard);

// Register the card with Home Assistant
window.customCards = window.customCards || [];
window.customCards.push({
  type: 'timeflow-card',
  name: 'TimeFlow Card',
  description: 'A beautiful countdown timer card with progress circle for Home Assistant',
  preview: true,
  documentationURL: 'https://github.com/Rishi8078/TimeFlow-Card'
});

console.info(
  `%c  TIMEFLOW-CARD  \n%c  Version ${TimeFlowCard.version}    `,
  'color: orange; font-weight: bold; background: black',
  'color: white; font-weight: bold; background: dimgray'
);

// Export main class for external use
